/**
 * MacGizmo GridGen Gerber Generator
 * Generates RS-274X Gerber files and Excellon drill files
 * for parametric prototype perfboards.
 *
 * Coordinate system: all internal units in mm,
 * Gerber output in mm with 4.6 format (4 integer, 6 decimal digits)
 *
 * DESIGN PRINCIPLE:
 * All pads (signal + rail) sit on the same unified grid.
 * Rails occupy the outermost 2 rows/columns of the grid.
 * VCC = outermost row/col, GND = next row/col inward.
 * Rail traces connect all pads of the same type in a straight line.
 * When rails meet at corners, VCC and GND lines are continuous.
 */

import { getTextStrokes, colLabel } from './font.js';

// ─── Configurable constants ───────────────────────────────────────────
/** Number of grid rows/cols used per rail (VCC + GND) */
export const RAIL_ROWS = 2;

/** Trace width for power rail connections (mm) */
export const RAIL_TRACE_WIDTH = 0.8;

/** Trace width used in Gerber aperture for rails (mm) */
export const GERBER_RAIL_TRACE_WIDTH = 0.8;

/** Board size constraints (mm) */
export const BOARD_MIN_WIDTH = 15;
export const BOARD_MAX_WIDTH = 200;
export const BOARD_MIN_HEIGHT = 10;
export const BOARD_MAX_HEIGHT = 200;

/** Mounting hole constants */
export const MOUNT_KEEPOUT_MARGIN = 0.5; // mm clearance around mounting hole (per side)

/** Available mounting hole diameters */
export const MOUNT_DIAMETERS = [2.5, 3.2, 4.0];

/** Mounting hole edge distance limits */
export const MOUNT_EDGE_MIN = 3;
export const MOUNT_EDGE_MAX = 15.0;

/** Label height in mm */
export const LABEL_HEIGHT = 1;
/** Label step interval (every N-th row/col gets a label) */
export const LABEL_STEP = 5;

// ─── Gerber format helpers ────────────────────────────────────────────

const GERBER_HEADER = (layerName) => `G04 MacGizmo GridGen - Parametric Prototype PCB*
G04 Layer: ${layerName}*
G04 Generated by MacGizmo GridGen*
%MOMM*%
%FSLAX46Y46*%
%IPPOS*%
`;

const GERBER_FOOTER = `M02*\n`;

function fmtCoord(mm) {
  return Math.round(mm * 1_000_000).toString();
}

function round4(val) {
  return Math.round(val * 10000) / 10000;
}

// ─── Mounting hole computation ────────────────────────────────────────

/**
 * Compute mounting hole positions based on config.
 * Keepout radius accounts for mounting hole + clearance + half copper pad diameter.
 * Returns array of { x, y, diameter, keepout }
 */
export function computeMountingHoles(config) {
  const { width, height, mountingHoles, padDiameter = 1.0, annularRing = 0.3 } = config;
  if (!mountingHoles || mountingHoles.mode === 'none') return [];

  const { diameter, edgeDistance } = mountingHoles;
  const copperPadRadius = (padDiameter + annularRing * 2) / 2;
  // Keepout = mounting hole radius + clearance + full copper pad diameter
  // so that no pad copper overlaps the hole area
  const keepout = diameter + MOUNT_KEEPOUT_MARGIN * 2 + copperPadRadius * 2;
  const holes = [];

  const x1 = edgeDistance;
  const y1 = edgeDistance;
  const x2 = width - edgeDistance;
  const y2 = height - edgeDistance;

  if (mountingHoles.mode === 'diagonal') {
    holes.push({ x: x1, y: y1, diameter, keepout });
    holes.push({ x: x2, y: y2, diameter, keepout });
  } else if (mountingHoles.mode === '4corners') {
    holes.push({ x: x1, y: y1, diameter, keepout });
    holes.push({ x: x2, y: y1, diameter, keepout });
    holes.push({ x: x1, y: y2, diameter, keepout });
    holes.push({ x: x2, y: y2, diameter, keepout });
  }

  return holes;
}

/**
 * Check if a pad position collides with any mounting hole keepout zone.
 */
export function isInKeepout(x, y, holes) {
  for (const h of holes) {
    const dx = x - h.x;
    const dy = y - h.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < h.keepout / 2) return true;
  }
  return false;
}

// ─── Grid computation ─────────────────────────────────────────────────

/**
 * Compute the unified grid: all pad positions on a single regular grid.
 * Rails are simply the outer rows/columns of this grid.
 *
 * Grid origin: centered on board.
 * Grid extends as far as possible while staying >= 1 pitch from edges.
 */
export function computeGrid(config) {
  const { width, height, pitch, labels = {} } = config;
  //const margin = pitch; // minimum edge distance  

  let marginCols = pitch + 0.5; // minimum edge distance  
  let marginRows = pitch + 0.5;
  let offsetCols = 0;
  let offsetRows = 0;  

  if(labels.rows)
  {
    //marginCols += 0.5;
    offsetCols = 0.2;
  }

  if(labels.cols)
  {
    marginRows +=  0.2;
    offsetRows = 0.2;
  }
  

  // Number of columns/rows that fit
  const cols = Math.max(0, Math.floor((width - 2 * marginCols) / pitch + 1));
  const rows = Math.max(0, Math.floor((height - 2 * marginRows) / pitch + 1));

  // Grid extent
  const gridWidth = (cols - 1) * pitch;
  const gridHeight = (rows - 1) * pitch;

  // Center the grid on the board
  const gridLeft = (width - gridWidth) / 2 + offsetCols;
  const gridBottom = (height - gridHeight) / 2 - offsetRows;
  const gridRight = gridLeft + (cols - 1) * pitch;
  const gridTop = gridBottom + (rows - 1) * pitch;

  return { gridLeft, gridTop, gridRight, gridBottom, cols, rows };
}

/**
 * Compute minimum board size based on active rails and mounting holes.
 * Each rail needs RAIL_ROWS grid rows/cols, plus at least 1 row/col for signal.
 */
export function computeMinSize(pitch, powerRails, mountingHoles) {
  const margin = pitch;
  const railCols = (powerRails.left ? RAIL_ROWS : 0) + (powerRails.right ? RAIL_ROWS : 0);
  const railRows = (powerRails.top ? RAIL_ROWS : 0) + (powerRails.bottom ? RAIL_ROWS : 0);

  // Need at least 1 signal col/row + rail cols/rows, all within margins
  const minCols = Math.max(3, railCols + 1);
  const minRows = Math.max(3, railRows + 1);

  let minWidth = Math.ceil(margin * 2 + (minCols - 1) * pitch);
  let minHeight = Math.ceil(margin * 2 + (minRows - 1) * pitch);

  // Mounting holes need enough space so they don't overlap each other
  if (mountingHoles && mountingHoles.mode !== 'none') {
    const { diameter, edgeDistance } = mountingHoles;
    const keepout = diameter + MOUNT_KEEPOUT_MARGIN * 2;
    // Need at least 2× edgeDistance + keepout so diagonal holes don't overlap
    const mountMin = edgeDistance * 2 + keepout;
    minWidth = Math.max(minWidth, Math.ceil(mountMin));
    minHeight = Math.max(minHeight, Math.ceil(mountMin));
  }

  return {
    minWidth: Math.max(BOARD_MIN_WIDTH, minWidth),
    minHeight: Math.max(BOARD_MIN_HEIGHT, minHeight),
  };
}

/**
 * Generate all pad positions with type classification.
 * Pads inside mounting hole keepout zones are excluded.
 * Returns array of { x, y, type: 'signal'|'vcc'|'gnd' }
 */
export function generatePadPositions(config, placedAdapters = []) {
  const { pitch, powerRails } = config;
  const { gridLeft, gridBottom, cols, rows } = computeGrid(config);
  const holes = computeMountingHoles(config);

  // Build set of grid positions occupied by adapter through-holes
  const adapterOccupied = new Set();
  for (const inst of placedAdapters) {
    const adapter = inst._adapterDef;
    if (!adapter) continue;
    // Block ALL grid positions within the adapter's footprint rectangle.
    // Through-hole interface pins get re-added by the adapter Gerber features.
    // Inner positions must be empty to avoid overlap with SMD pads and traces.
    for (let c = 0; c < adapter.widthPins; c++) {
      for (let r = 0; r < adapter.heightPins; r++) {
        adapterOccupied.add(`${inst.col + c},${inst.row + r}`);
      }
    }
  }

  const pads = [];

  for (let col = 0; col < cols; col++) {
    for (let row = 0; row < rows; row++) {
      const x = round4(gridLeft + col * pitch);
      const y = round4(gridBottom + row * pitch);

      // Skip pads inside mounting hole keepout zones
      if (isInKeepout(x, y, holes)) continue;
      
      // Skip pads occupied by adapter through-holes
      if (adapterOccupied.has(`${col},${row}`)) continue;

      const type = classifyPad(col, row, cols, rows, powerRails);
      pads.push({ x, y, type });
    }
  }

  return pads;
}

/**
 * Classify a pad based on its grid position and active rails.
 * VCC = outermost rail row/col, GND = next inward.
 * VCC always wins over GND at intersections.
 */
function classifyPad(col, row, cols, rows, rails) {
  const isLeftVcc = rails.left && col === 0;
  const isLeftGnd = rails.left && col === 1;
  const isRightVcc = rails.right && col === cols - 1;
  const isRightGnd = rails.right && col === cols - 2;

  const isBottomVcc = rails.bottom && row === 0;
  const isBottomGnd = rails.bottom && row === 1;
  const isTopVcc = rails.top && row === rows - 1;
  const isTopGnd = rails.top && row === rows - 2;

  const isVcc = isTopVcc || isBottomVcc || isLeftVcc || isRightVcc;
  const isGnd = isTopGnd || isBottomGnd || isLeftGnd || isRightGnd;

  // VCC always wins over GND at intersections
  if (isVcc) return 'vcc';
  if (isGnd) return 'gnd';

  return 'signal';
}

/**
 * Generate power rail traces, clipped around mounting hole keepout zones.
 * Each rail is a straight line connecting pads of the same type.
 * Traces that intersect keepout zones are split into segments.
 */
export function generatePowerRailTraces(config) {
  const { powerRails, pitch } = config;
  const { gridLeft, gridTop, gridRight, gridBottom } = computeGrid(config);
  const holes = computeMountingHoles(config);

  const rawTraces = [];

  // ── Horizontal rails (top / bottom) ──
  if (rails('top')) {
    const y0 = gridTop;
    const y1 = gridTop - pitch;
    const gndX1 = gridLeft + (powerRails.left ? pitch : 0);
    const gndX2 = gridRight - (powerRails.right ? pitch : 0);
    rawTraces.push({ x1: gridLeft, y1: y0, x2: gridRight, y2: y0, type: 'vcc' });
    rawTraces.push({ x1: gndX1, y1: y1, x2: gndX2, y2: y1, type: 'gnd' });
  }

  if (rails('bottom')) {
    const y0 = gridBottom;
    const y1 = gridBottom + pitch;
    const gndX1 = gridLeft + (powerRails.left ? pitch : 0);
    const gndX2 = gridRight - (powerRails.right ? pitch : 0);
    rawTraces.push({ x1: gridLeft, y1: y0, x2: gridRight, y2: y0, type: 'vcc' });
    rawTraces.push({ x1: gndX1, y1: y1, x2: gndX2, y2: y1, type: 'gnd' });
  }

  // ── Vertical rails (left / right) ──
  if (rails('left')) {
    const x0 = gridLeft;
    const x1g = gridLeft + pitch;
    const gndY1 = gridTop - (powerRails.top ? pitch : 0);
    const gndY2 = gridBottom + (powerRails.bottom ? pitch : 0);
    rawTraces.push({ x1: x0, y1: gridTop, x2: x0, y2: gridBottom, type: 'vcc' });
    rawTraces.push({ x1: x1g, y1: gndY1, x2: x1g, y2: gndY2, type: 'gnd' });
  }

  if (rails('right')) {
    const x0 = gridRight;
    const x1g = gridRight - pitch;
    const gndY1 = gridTop - (powerRails.top ? pitch : 0);
    const gndY2 = gridBottom + (powerRails.bottom ? pitch : 0);
    rawTraces.push({ x1: x0, y1: gridTop, x2: x0, y2: gridBottom, type: 'vcc' });
    rawTraces.push({ x1: x1g, y1: gndY1, x2: x1g, y2: gndY2, type: 'gnd' });
  }

  // Clip all traces around mounting hole keepout zones
  if (holes.length === 0) return rawTraces;

  const clipped = [];
  for (const trace of rawTraces) {
    const segments = clipTraceAroundHoles(trace, holes);
    clipped.push(...segments);
  }
  return clipped;

  function rails(side) { return powerRails[side]; }
}

/**
 * Clip a single trace (horizontal or vertical) around circular keepout zones.
 * Returns an array of trace segments that don't intersect any keepout.
 */
function clipTraceAroundHoles(trace, holes) {
  const { x1, y1, x2, y2, type } = trace;
  const isHorizontal = Math.abs(y1 - y2) < 0.001;
  const isVertical = Math.abs(x1 - x2) < 0.001;

  if (!isHorizontal && !isVertical) return [trace]; // safety: only axis-aligned

  if (isHorizontal) {
    // Trace runs along Y=y1 from x1 to x2
    const y = y1;
    const minX = Math.min(x1, x2);
    const maxX = Math.max(x1, x2);

    // Collect exclusion intervals [start, end] along X axis
    const exclusions = [];
    for (const h of holes) {
      const dy = Math.abs(y - h.y);
      const r = h.keepout / 2;
      if (dy >= r) continue; // trace doesn't pass through this keepout
      // Half-chord length at this Y distance
      const halfChord = Math.sqrt(r * r - dy * dy);
      const exStart = h.x - halfChord;
      const exEnd = h.x + halfChord;
      exclusions.push([exStart, exEnd]);
    }

    return buildSegments(minX, maxX, exclusions, (a, b) => ({
      x1: a, y1: y, x2: b, y2: y, type
    }));
  } else {
    // Vertical: trace runs along X=x1 from y1 to y2
    const x = x1;
    const minY = Math.min(y1, y2);
    const maxY = Math.max(y1, y2);

    const exclusions = [];
    for (const h of holes) {
      const dx = Math.abs(x - h.x);
      const r = h.keepout / 2;
      if (dx >= r) continue;
      const halfChord = Math.sqrt(r * r - dx * dx);
      const exStart = h.y - halfChord;
      const exEnd = h.y + halfChord;
      exclusions.push([exStart, exEnd]);
    }

    return buildSegments(minY, maxY, exclusions, (a, b) => ({
      x1: x, y1: a, x2: x, y2: b, type
    }));
  }
}

/**
 * Given a range [start, end] and a list of exclusion intervals,
 * return the non-excluded segments using a builder function.
 */
function buildSegments(start, end, exclusions, builder) {
  if (exclusions.length === 0) return [builder(start, end)];

  // Sort exclusions by start
  exclusions.sort((a, b) => a[0] - b[0]);

  // Merge overlapping exclusions
  const merged = [exclusions[0]];
  for (let i = 1; i < exclusions.length; i++) {
    const last = merged[merged.length - 1];
    if (exclusions[i][0] <= last[1]) {
      last[1] = Math.max(last[1], exclusions[i][1]);
    } else {
      merged.push(exclusions[i]);
    }
  }

  // Build segments between exclusions
  const segments = [];
  let cursor = start;
  for (const [exStart, exEnd] of merged) {
    const segEnd = Math.max(cursor, Math.min(exStart, end));
    if (segEnd > cursor + 0.01) {
      segments.push(builder(cursor, segEnd));
    }
    cursor = Math.max(cursor, exEnd);
  }
  if (cursor < end - 0.01) {
    segments.push(builder(cursor, end));
  }

  return segments;
}

/**
 * Compute signal grid dimensions (excluding rail rows/cols)
 */
export function computeSignalGrid(config) {
  const { powerRails } = config;
  const { cols, rows } = computeGrid(config);

  const railCols = (powerRails.left ? RAIL_ROWS : 0) + (powerRails.right ? RAIL_ROWS : 0);
  const railRows = (powerRails.top ? RAIL_ROWS : 0) + (powerRails.bottom ? RAIL_ROWS : 0);

  const sigCols = Math.max(0, cols - railCols);
  const sigRows = Math.max(0, rows - railRows);

  const pads = generatePadPositions(config);
  const signalPads = pads.filter(p => p.type === 'signal').length;

  return { cols: sigCols, rows: sigRows, total: signalPads };

}

// ─── Gerber file generators ───────────────────────────────────────────

export function generateEdgeCuts(config) {
  const { width, height } = config;
  let gerber = GERBER_HEADER('Edge.Cuts');

  gerber += `%ADD10C,0.100000*%\n`;
  gerber += `D10*\n`;

  gerber += `X${fmtCoord(0)}Y${fmtCoord(0)}D02*\n`;
  gerber += `X${fmtCoord(width)}Y${fmtCoord(0)}D01*\n`;
  gerber += `X${fmtCoord(width)}Y${fmtCoord(height)}D01*\n`;
  gerber += `X${fmtCoord(0)}Y${fmtCoord(height)}D01*\n`;
  gerber += `X${fmtCoord(0)}Y${fmtCoord(0)}D01*\n`;

  gerber += GERBER_FOOTER;
  return gerber;
}

export function generateCopperLayer(config, layerName = 'B.Cu', placedAdapters = []) {
  const pads = generatePadPositions(config, placedAdapters);
  const traces = generatePowerRailTraces(config);
  const holes = computeMountingHoles(config);
  const { padDiameter, annularRing, pitch } = config;
  const { gridLeft, gridBottom } = computeGrid(config);

  let gerber = GERBER_HEADER(layerName);

  const copperPadDia = padDiameter + annularRing * 2;
  gerber += `%ADD10C,${copperPadDia.toFixed(6)}*%\n`; // Signal pad
  gerber += `%ADD11C,${copperPadDia.toFixed(6)}*%\n`; // VCC pad
  gerber += `%ADD12C,${copperPadDia.toFixed(6)}*%\n`; // GND pad
  gerber += `%ADD20C,${GERBER_RAIL_TRACE_WIDTH.toFixed(6)}*%\n`; // Rail trace

  // Mounting hole keepout aperture (clear copper around holes)
  if (holes.length > 0) {
    const keepoutDia = holes[0].keepout;
    gerber += `%ADD30C,${keepoutDia.toFixed(6)}*%\n`;
  }

  // Collect adapter copper features with unique apertures (starting D40)
  const adapterFeatures = [];
  const rectApertures = new Map();
  const thSeen = new Set(); // deduplicate through-hole positions
  let nextAperture = 40;

  for (const inst of placedAdapters) {
    const adapter = inst._adapterDef;
    if (!adapter) continue;
    const originX = gridLeft + inst.col * pitch;
    const originY = gridBottom + inst.row * pitch;

    for (const f of adapter.features.copper) {
      if (f.type === 'pad') {
        const key = `${f.w.toFixed(4)},${f.h.toFixed(4)}`;
        if (!rectApertures.has(key)) rectApertures.set(key, nextAperture++);        
        adapterFeatures.push({
          type: 'pad', x: originX + f.x, y: originY + f.y,
          aperture: rectApertures.get(key),
        });
      } else if (f.type === 'trace') {
        const key = `T${f.w.toFixed(4)}`;
        if (!rectApertures.has(key)) rectApertures.set(key, nextAperture++);
         adapterFeatures.push({
          type: 'trace',
          x1: originX + f.x1, y1: originY + f.y1,
          x2: originX + f.x2, y2: originY + f.y2,
          aperture: rectApertures.get(key),
        });
      }
    }

    // Through-hole pads at adapter pin positions (deduplicated)
    for (const pin of adapter.throughPins) {
      const x = round4(gridLeft + (inst.col + pin.col) * pitch);
      const y = round4(gridBottom + (inst.row + pin.row) * pitch);
      const key = `${fmtCoord(x)},${fmtCoord(y)}`;
      if (!thSeen.has(key)) {
        thSeen.add(key);
        adapterFeatures.push({ type: 'th', x, y });
      }
    }
  }

  // Define adapter apertures
  for (const [key, num] of rectApertures) {
    if (key.startsWith('T')) {
      gerber += `%ADD${num}C,${parseFloat(key.substring(1)).toFixed(6)}*%\n`;
    } else {
      const [w, h] = key.split(',').map(Number);
      gerber += `%ADD${num}R,${w.toFixed(6)}X${h.toFixed(6)}*%\n`;
    }
  }

  // Flash grid pads
  for (const pad of pads) {
    const aperture = pad.type === 'vcc' ? 'D11' : pad.type === 'gnd' ? 'D12' : 'D10';
    gerber += `${aperture}*\n`;
    gerber += `X${fmtCoord(pad.x)}Y${fmtCoord(pad.y)}D03*\n`;
  }

  // Draw power rail traces
  if (traces.length > 0) {
    gerber += `D20*\n`;
    for (const t of traces) {
      gerber += `X${fmtCoord(t.x1)}Y${fmtCoord(t.y1)}D02*\n`;
      gerber += `X${fmtCoord(t.x2)}Y${fmtCoord(t.y2)}D01*\n`;
    }
  }

  // Flash adapter features
  for (const f of adapterFeatures) {
    if (f.type === 'pad') {
      gerber += `D${f.aperture}*\n`;
      gerber += `X${fmtCoord(f.x)}Y${fmtCoord(f.y)}D03*\n`;
    } else if (f.type === 'trace') {
      gerber += `D${f.aperture}*\n`;
      gerber += `X${fmtCoord(f.x1)}Y${fmtCoord(f.y1)}D02*\n`;
      gerber += `X${fmtCoord(f.x2)}Y${fmtCoord(f.y2)}D01*\n`;
    } else if (f.type === 'th') {
      gerber += `D10*\n`;
      gerber += `X${fmtCoord(f.x)}Y${fmtCoord(f.y)}D03*\n`;
    }
  }

  gerber += GERBER_FOOTER;
  return gerber;
}

export function generateSolderMask(config, layerName = 'B.Mask', placedAdapters = []) {
  const pads = generatePadPositions(config, placedAdapters);
  const holes = computeMountingHoles(config);
  const { padDiameter, annularRing, maskExpansion, pitch } = config;
  const { gridLeft, gridBottom } = computeGrid(config);

  let gerber = GERBER_HEADER(layerName);

  const maskDia = padDiameter + annularRing * 2 + maskExpansion * 2;
  gerber += `%ADD10C,${maskDia.toFixed(6)}*%\n`;

  // Mounting hole mask opening (expose copper-free area)
  if (holes.length > 0) {
    const holeMaskDia = holes[0].diameter + maskExpansion * 4;
    gerber += `%ADD30C,${holeMaskDia.toFixed(6)}*%\n`;
  }

  // Collect adapter mask apertures
  const rectApertures = new Map();
  let nextAperture = 40;
  const adapterMask = [];
  const maskThSeen = new Set();

  for (const inst of placedAdapters) {
    const adapter = inst._adapterDef;
    if (!adapter) continue;
    const originX = gridLeft + inst.col * pitch;
    const originY = gridBottom + inst.row * pitch;

    for (const f of adapter.features.mask) {
      if (f.type === 'pad') {
        const key = `${f.w.toFixed(4)},${f.h.toFixed(4)}`;
        if (!rectApertures.has(key)) rectApertures.set(key, nextAperture++);
        adapterMask.push({ x: originX + f.x, y: originY + f.y, aperture: rectApertures.get(key) });
      }
    }
for (const pin of adapter.throughPins) {
      const x = round4(gridLeft + (inst.col + pin.col) * pitch);
      const y = round4(gridBottom + (inst.row + pin.row) * pitch);
      const key = `${fmtCoord(x)},${fmtCoord(y)}`;
      if (!maskThSeen.has(key)) {
        maskThSeen.add(key);
        adapterMask.push({ x, y, aperture: 10 });
      }
    }
  }

  for (const [key, num] of rectApertures) {
    const [w, h] = key.split(',').map(Number);
    gerber += `%ADD${num}R,${w.toFixed(6)}X${h.toFixed(6)}*%\n`;
  }

  gerber += `D10*\n`;
  for (const pad of pads) {
    gerber += `X${fmtCoord(pad.x)}Y${fmtCoord(pad.y)}D03*\n`;
  }

  if (holes.length > 0) {
    gerber += `D30*\n`;
    for (const h of holes) {
      gerber += `X${fmtCoord(h.x)}Y${fmtCoord(h.y)}D03*\n`;
    }
  }

  for (const f of adapterMask) {
    gerber += `D${f.aperture}*\n`;
    gerber += `X${fmtCoord(f.x)}Y${fmtCoord(f.y)}D03*\n`;
  }

  gerber += GERBER_FOOTER;
  return gerber;
}

export function generateSilkscreen(config, placedAdapters = []) {
  const { labels = {}, pitch } = config;
  const { gridLeft, gridBottom } = computeGrid(config);
  const strokes = generateLabelStrokes(config);

  let gerber = GERBER_HEADER('F.Silkscreen');
  gerber += `%ADD10C,0.150000*%\n`; // stroke width 0.15mm
  gerber += `D10*\n`;

  for (const polyline of strokes) {
    if (polyline.length < 2) continue;
    // Move to first point
    gerber += `X${fmtCoord(polyline[0].x)}Y${fmtCoord(polyline[0].y)}D02*\n`;
    // Draw to subsequent points
    for (let i = 1; i < polyline.length; i++) {
      gerber += `X${fmtCoord(polyline[i].x)}Y${fmtCoord(polyline[i].y)}D01*\n`;
    }
  }
  
  // Adapter silkscreen features
  for (const inst of placedAdapters) {
    const adapter = inst._adapterDef;
    if (!adapter) continue;
    const originX = gridLeft + inst.col * pitch;
    const originY = gridBottom + inst.row * pitch;

    for (const f of adapter.features.silk) {
      if (f.type === 'poly') {
        const pts = f.points;
        if (pts.length < 2) continue;
        gerber += `X${fmtCoord(originX + pts[0].x)}Y${fmtCoord(originY + pts[0].y)}D02*\n`;
        for (let i = 1; i < pts.length; i++) {
          gerber += `X${fmtCoord(originX + pts[i].x)}Y${fmtCoord(originY + pts[i].y)}D01*\n`;
        }
      } else if (f.type === 'circle') {
        // Approximate small circle as flash
        gerber += `X${fmtCoord(originX + f.x)}Y${fmtCoord(originY + f.y)}D03*\n`;
      }
    }
  }

  gerber += GERBER_FOOTER;
  return gerber;
}


/**
 * Generate label strokes for silkscreen.
 * Row labels (1, 5, 10, ...) on the left of the grid.
 * Column labels (A, E, J, ...) above the grid.
 * Returns array of polylines for both Gerber and SVG preview.
 */
export function generateLabelStrokes(config) {
  const { labels = {}, powerRails, pitch, padDiameter = 1.0, annularRing = 0.3 } = config;
  const { gridLeft, gridTop, gridRight, gridBottom, cols, rows } = computeGrid(config);
  const holes = computeMountingHoles(config);
  const allStrokes = [];
  const h = LABEL_HEIGHT;
  const copperRadius = (padDiameter + annularRing * 2) / 2;
  // Gap = enough to clear the copper pad edge + small margin
  const gap = copperRadius + h * 0.8;

  // Tick mark size (small dot for unlabeled rows/cols)
  const tickR = 0.2;  // radius of tick dot

  // How many grid cols/rows are used by rails
  const railColsLeft = powerRails.left ? RAIL_ROWS : 0;
  const railColsRight = powerRails.right ? RAIL_ROWS : 0;
  const railRowsTop = powerRails.top ? RAIL_ROWS : 0;
  const railRowsBottom = powerRails.bottom ? RAIL_ROWS : 0;

  // Signal grid indices
  const sigColStart = railColsLeft;
  const sigColEnd = cols - railColsRight - 1;
  const sigRowStart = railRowsTop;
  const sigRowEnd = rows - railRowsBottom - 1;

  // Label step logic: label "1" always shown, then based on step value
  // step=1: every row/col, step=2: every 2nd, step=5: every 5th
  // sigIndex is 0-based, label number is sigIndex+1

  function shouldLabel(sigIndex, sigMax, step) {
    if (step <= 1) return true;                                   // label every one
    if (sigIndex === 0) return true;                              // first
    if (sigIndex === sigMax) return true;                         // last
    if ((sigIndex + 1) % step === 0) return true;           // 5, 10, 15, ...
    return false;
  }
  
  /**
   * Check if a label at (x, y) with given size would overlap a mounting hole keepout.
   * Uses a conservative rectangular bounding box for the label.
   */
  function labelOverlapsHole(x, y) {
    // Check center point and nearby points against keepout
    return isInKeepout(x, y, holes);
  }

  /**
   * Generate a small cross/tick mark as a polyline pair.
   */
  function tickMark(x, y) {
    return [
      [{ x: x - tickR, y }, { x: x + tickR, y }],
      [{ x, y: y - tickR }, { x, y: y + tickR }],
    ];
  }

  // ── Row labels (left side, numbers 1-based) ──
  // Gerber coords: Y increases upward, row 0 is at gridTop (highest Y)
  const rowStep = labels.rows || 0;
  if (rowStep > 0) {
    const sigRowCount = sigRowEnd - sigRowStart;
    for (let row = sigRowStart; row <= sigRowEnd; row++) {
      const sigRow = row - sigRowStart;
      const y = gridTop - row * pitch;
      const x = gridLeft - gap;

      if (shouldLabel(sigRow, sigRowCount, rowStep)) {
        // Full text label – skip if overlapping mounting hole
        if (!labelOverlapsHole(x, y)) {
          const text = String(sigRow + 1);
          const strokes = getTextStrokes(text, x, y, h, 'right');
          allStrokes.push(...strokes);
                  }
        } else if (rowStep > 1) {
        // Tick mark for intermediate rows (only when not labeling every row)
            const tx = gridLeft - gap;
            if (!labelOverlapsHole(tx, y)) {
              allStrokes.push(...tickMark(tx, y));
            }
          }
      }
  }

  // ── Column labels (top side, letters A-based) ──
  const colStep = labels.cols || 0;
  if (colStep > 0) {
    const sigColCount = sigColEnd - sigColStart;
    for (let col = sigColStart; col <= sigColEnd; col++) {
      const sigCol = col - sigColStart;
      const x = gridLeft + col * pitch;
      const y = gridTop + gap;

      if (shouldLabel(sigCol, sigColCount, colStep)) {
        // Full text label – skip if overlapping mounting hole
        if (!labelOverlapsHole(x, y)) {
      const text = colLabel(sigCol);
      const strokes = getTextStrokes(text, x, y, h, 'center');
      allStrokes.push(...strokes);
              }
      } else if (colStep > 1) {
        // Tick mark for intermediate columns (only when not labeling every col)
        const ty = gridTop + gap;
        if (!labelOverlapsHole(x, ty)) {
          allStrokes.push(...tickMark(x, ty));
        }
      }
    }
  }

  // ── Branding (bottom-right, shifted if holes block) ──
  const brandText = 'MACGIZMO GRIDGEN';
  const brandH = LABEL_HEIGHT;
  const scale = brandH / 5;
  const charWidth = 3 * scale;
  const charGap = 1 * scale;
  const brandWidth = brandText.length * charWidth + (brandText.length - 1) * charGap;

  // Desired position: right-aligned at gridRight, below grid
  let brandX = gridRight + gap;
  let brandY = gridBottom - gap;

  // Find if any hole blocks the branding area
  // Check along the text extent (right-aligned, so text runs from brandX-brandWidth to brandX)
  function brandBlocked(bx, by) {
    // Sample several points along the text
    const textLeft = bx - brandWidth;
    for (let sx = textLeft; sx <= bx; sx += charWidth) {
      if (isInKeepout(sx, by, holes)) return true;
    }
    return false;
  }

  let brandPlaced = false;

  // Attempt 1: default position (bottom-right)
  if (brandY + brandH / 2 < config.height && !brandBlocked(brandX, brandY)) {
    brandPlaced = true;
  }

  // Attempt 2: shift left to clear bottom-right hole
  if (!brandPlaced) {
    // Find the leftmost keepout edge at brandY height
    for (const h of holes) {
      const dy = Math.abs(brandY - h.y);
      const r = h.keepout / 2;
      if (dy < r) {
        const shiftedX = h.x - r - gap;
        if (shiftedX - brandWidth > 0 && !brandBlocked(shiftedX, brandY)) {
          brandX = shiftedX;
          brandPlaced = true;
          break;
        }
      }
    }
  }

  // Attempt 3: move to bottom-left (left-aligned)
  if (!brandPlaced) {
    const altX = gridLeft - gap;
    const altY = brandY;
    if (altY + brandH / 2 < config.height && altX + brandWidth < config.width) {
      if (!brandBlocked(altX + brandWidth, altY)) {
        brandX = altX + brandWidth;
        brandPlaced = true;
      }
    }
  }

  if (brandPlaced) {
    const brandStrokes = getTextStrokes(brandText, brandX, brandY, brandH, 'right');
    allStrokes.push(...brandStrokes);
  }

 /*
  // ── Branding (bottom-right, always shown) ──
  const brandText = 'MACGIZMO GRIDGEN';
  const brandH = LABEL_HEIGHT;  
  const brandX = gridRight + gap;
  const brandY = gridBottom - gap;
  const brandStrokes = getTextStrokes(brandText, brandX, brandY, brandH, 'right');
  // Only add if text fits within board boundaries
  if (brandY + brandH / 2 < config.height) {
    allStrokes.push(...brandStrokes);
  }*/

  return allStrokes;
}


export function generateDrillFile(config, placedAdapters = []) {
  const pads = generatePadPositions(config, placedAdapters);
  const holes = computeMountingHoles(config);
  const { padDiameter, pitch } = config;
  const { gridLeft, gridBottom } = computeGrid(config);

  let drill = `; MacGizmo GridGen - Parametric Prototype PCB\n`;
  drill += `; Drill file - Excellon format\n`;
  drill += `M48\n`;
  drill += `METRIC,TZ\n`;
  drill += `T1C${padDiameter.toFixed(3)}\n`;

  // Separate tool for mounting holes if present
  if (holes.length > 0) {
    drill += `T2C${holes[0].diameter.toFixed(3)}\n`;
  }

  drill += `%\n`;

  // Pad drill holes (grid pads, adapter TH pads excluded from grid)
  drill += `T1\n`;
  for (const pad of pads) {
    drill += `X${pad.x.toFixed(3)}Y${pad.y.toFixed(3)}\n`;
  }
  
  // Adapter through-hole drill positions (deduplicated, same diameter as grid pads)
  const drillSeen = new Set();
  for (const inst of placedAdapters) {
    const adapter = inst._adapterDef;
    if (!adapter) continue;
    for (const pin of adapter.throughPins) {
      const px = round4(gridLeft + (inst.col + pin.col) * pitch);
      const py = round4(gridBottom + (inst.row + pin.row) * pitch);
      const key = `${px.toFixed(3)},${py.toFixed(3)}`;
      if (!drillSeen.has(key)) {
        drillSeen.add(key);
        drill += `X${px.toFixed(3)}Y${py.toFixed(3)}\n`;
      }
    }
  }

  // Mounting drill holes
  if (holes.length > 0) {
    drill += `T2\n`;
    for (const h of holes) {
      drill += `X${h.x.toFixed(3)}Y${h.y.toFixed(3)}\n`;
    }
  }

  drill += `M30\n`;
  return drill;
}

/**
 * Generate complete Gerber file set.
 * @param {Object} config - Board configuration
 * @param {Array} placedAdapters - Array of placed adapter instances with _adapterDef attached
 */
export function generateAllFiles(config, placedAdapters = []) {
  const cfg = {
    maskExpansion: 0.05,
    ...config,
  };

  return {
    'MacGizmoGrid-Edge_Cuts.gbr': generateEdgeCuts(cfg),
    'MacGizmoGrid-B_Cu.gbr': generateCopperLayer(cfg, 'B.Cu', placedAdapters),
    'MacGizmoGrid-F_Cu.gbr': generateCopperLayer(cfg, 'F.Cu', placedAdapters),
    'MacGizmoGrid-B_Mask.gbr': generateSolderMask(cfg, 'B.Mask', placedAdapters),
    'MacGizmoGrid-F_Mask.gbr': generateSolderMask(cfg, 'F.Mask', placedAdapters),
    'MacGizmoGrid-F_Silkscreen.gbr': generateSilkscreen(cfg, placedAdapters),
    'MacGizmoGrid.drl': generateDrillFile(cfg, placedAdapters),
  };
}