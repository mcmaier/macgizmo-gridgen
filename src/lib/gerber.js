/**
 * ProtoGrid Gerber Generator
 * Generates RS-274X Gerber files and Excellon drill files
 * for parametric prototype perfboards.
 *
 * Coordinate system: all internal units in mm,
 * Gerber output in mm with 4.6 format (4 integer, 6 decimal digits)
 *
 * DESIGN PRINCIPLE:
 * All pads (signal + rail) sit on the same unified grid.
 * Rails occupy the outermost 2 rows/columns of the grid.
 * VCC = outermost row/col, GND = next row/col inward.
 * Rail traces connect all pads of the same type in a straight line.
 * When rails meet at corners, VCC and GND lines are continuous.
 */

// ─── Configurable constants ───────────────────────────────────────────
/** Number of grid rows/cols used per rail (VCC + GND) */
export const RAIL_ROWS = 2;

/** Trace width for power rail connections (mm) */
export const RAIL_TRACE_WIDTH = 0.8;

/** Trace width used in Gerber aperture for rails (mm) */
export const GERBER_RAIL_TRACE_WIDTH = 0.8;

/** Board size constraints (mm) */
export const BOARD_MIN_WIDTH = 10;
export const BOARD_MAX_WIDTH = 200;
export const BOARD_MIN_HEIGHT = 10;
export const BOARD_MAX_HEIGHT = 200;

// ─── Gerber format helpers ────────────────────────────────────────────

const GERBER_HEADER = (layerName) => `G04 ProtoGrid - Parametric Prototype PCB*
G04 Layer: ${layerName}*
G04 Generated by MacGizmo ProtoGrid*
%MOMM*%
%FSLAX46Y46*%
%IPPOS*%
`;

const GERBER_FOOTER = `M02*\n`;

function fmtCoord(mm) {
  return Math.round(mm * 1_000_000).toString();
}

function round4(val) {
  return Math.round(val * 10000) / 10000;
}

// ─── Grid computation ─────────────────────────────────────────────────

/**
 * Compute the unified grid: all pad positions on a single regular grid.
 * Rails are simply the outer rows/columns of this grid.
 *
 * Grid origin: one pitch inset from each board edge.
 * Grid extends as far as possible while staying >= 1 pitch from edges.
 */
export function computeGrid(config) {
  const { width, height, pitch, powerRails } = config;
  const margin = pitch; // minimum edge distance

  // Number of columns/rows that fit
  const cols = Math.max(0, Math.floor((width - 2 * margin) / pitch) + 1);
  const rows = Math.max(0, Math.floor((height - 2 * margin) / pitch) + 1);

  // Grid extent
  const gridWidth = (cols - 1) * pitch;
  const gridHeight = (rows - 1) * pitch;
  
  // Center the grid on the board
  const gridLeft = (width - gridWidth) / 2;
  const gridTop = (height - gridHeight) / 2;
  const gridRight = gridLeft + (cols - 1) * pitch;
  const gridBottom = gridTop + (rows - 1) * pitch;

  return { gridLeft, gridTop, gridRight, gridBottom, cols, rows, margin };
}

/**
 * Compute minimum board size based on active rails.
 * Each rail needs RAIL_ROWS grid rows/cols, plus at least 1 row/col for signal.
 */
export function computeMinSize(pitch, powerRails) {
  const margin = pitch;
  const railCols = (powerRails.left ? RAIL_ROWS : 0) + (powerRails.right ? RAIL_ROWS : 0);
  const railRows = (powerRails.top ? RAIL_ROWS : 0) + (powerRails.bottom ? RAIL_ROWS : 0);

  // Need at least 1 signal col/row + rail cols/rows, all within margins
  const minCols = Math.max(3, railCols + 1);
  const minRows = Math.max(3, railRows + 1);

  const minWidth = Math.ceil(margin * 2 + (minCols - 1) * pitch);
  const minHeight = Math.ceil(margin * 2 + (minRows - 1) * pitch);

  return {
    minWidth: Math.max(BOARD_MIN_WIDTH, minWidth),
    minHeight: Math.max(BOARD_MIN_HEIGHT, minHeight),
  };
}

/**
 * Generate all pad positions with type classification.
 * Returns array of { x, y, type: 'signal'|'vcc'|'gnd' }
 */
export function generatePadPositions(config) {
  const { width, height, pitch, powerRails } = config;
  const { gridLeft, gridTop, cols, rows } = computeGrid(config);

  const pads = [];

  for (let col = 0; col < cols; col++) {
    for (let row = 0; row < rows; row++) {
      const x = round4(gridLeft + col * pitch);
      const y = round4(gridTop + row * pitch);

      // Determine pad type based on grid position
      const type = classifyPad(col, row, cols, rows, powerRails);
      pads.push({ x, y, type });
    }
  }

  return pads;
}

/**
 * Classify a pad based on its grid position and active rails.
 * VCC = outermost rail row/col, GND = next inward.
 * Corner pads where two rails meet: horizontal rail takes priority
 * (so the trace routing is consistent).
 */
function classifyPad(col, row, cols, rows, rails) {
  const isLeftVcc = rails.left && col === 0;
  const isLeftGnd = rails.left && col === 1;
  const isRightVcc = rails.right && col === cols - 1;
  const isRightGnd = rails.right && col === cols - 2;

  const isTopVcc = rails.top && row === 0;
  const isTopGnd = rails.top && row === 1;
  const isBottomVcc = rails.bottom && row === rows - 1;
  const isBottomGnd = rails.bottom && row === rows - 2;

  const isVcc = isTopVcc || isBottomVcc || isLeftVcc || isRightVcc;
  const isGnd = isTopGnd || isBottomGnd || isLeftGnd || isRightGnd;

  // VCC always wins over GND at intersections
  if (isVcc) return 'vcc';
  if (isGnd) return 'gnd';

  return 'signal';
}

/**
 * Generate power rail traces.
 * Each rail is a straight line connecting all pads of the same type.
 * Corner connections: when two rails meet, traces extend to overlap.
 */
export function generatePowerRailTraces(config) {
  const { width, height, pitch, powerRails } = config;
  const { gridLeft, gridTop, gridRight, gridBottom, cols, rows } = computeGrid(config);

  const traces = [];

  // Helper: extend trace endpoints to connect at corners
  // When two perpendicular rails meet, extend the trace by half a pitch
  // so VCC connects to VCC and GND connects to GND at the corner.

  // ── Horizontal rails (top / bottom) ──
  if (rails('top')) {
    const y0 = gridTop;              // VCC row
    const y1 = gridTop + pitch;      // GND row
    const x1 = gridLeft;
    const x2 = gridRight;
    const gndX1 = gridLeft    + (powerRails.left ? pitch : 0);
    const gndX2 = gridRight - (powerRails.right ? pitch : 0);
    traces.push({ x1, y1: y0, x2, y2: y0, type: 'vcc' });
    traces.push({ x1 : gndX1, y1: y1, x2: gndX2, y2: y1, type: 'gnd' });
  }

  if (rails('bottom')) {
    const y0 = gridBottom;           // VCC row
    const y1 = gridBottom - pitch;   // GND row
    const x1 = gridLeft;
    const x2 = gridRight;
    const gndX1 = gridLeft + (powerRails.left ? pitch : 0);
    const gndX2 = gridRight - (powerRails.right ? pitch : 0);
    traces.push({ x1, y1: y0, x2, y2: y0, type: 'vcc' });
    traces.push({ x1 : gndX1, y1: y1, x2: gndX2, y2: y1, type: 'gnd' });
  }

  // ── Vertical rails (left / right) ──
  // GND col: shorten to avoid overlapping into VCC rows of perpendicular rails
  if (rails('left')) {
    const x0 = gridLeft;             // VCC col
    const x1 = gridLeft + pitch;     // GND col
    const y1 = gridTop;
    const y2 = gridBottom;
    const gndY1 = gridTop    + (powerRails.top    ? pitch : 0);
    const gndY2 = gridBottom - (powerRails.bottom ? pitch : 0);
    traces.push({ x1: x1, y1: gndY1, x2: x1, y2: gndY2, type: 'gnd' });
    traces.push({ x1: x0, y1, x2: x0, y2, type: 'vcc' });
  }

  if (rails('right')) {
    const x0 = gridRight;            // VCC col
    const x1 = gridRight - pitch;    // GND col
    const y1 = gridTop;
    const y2 = gridBottom;
    const gndY1 = gridTop    + (powerRails.top    ? pitch : 0);
    const gndY2 = gridBottom - (powerRails.bottom ? pitch : 0);
    traces.push({ x1: x1, y1: gndY1, x2: x1, y2: gndY2, type: 'gnd' });
    traces.push({ x1: x0, y1, x2: x0, y2, type: 'vcc' });
  }

  return traces;

  function rails(side) { return powerRails[side]; }
}

/**
 * Compute signal grid dimensions (excluding rail rows/cols)
 */
export function computeSignalGrid(config) {
  const { powerRails } = config;
  const { cols, rows } = computeGrid(config);

  const railCols = (powerRails.left ? RAIL_ROWS : 0) + (powerRails.right ? RAIL_ROWS : 0);
  const railRows = (powerRails.top ? RAIL_ROWS : 0) + (powerRails.bottom ? RAIL_ROWS : 0);

  const sigCols = Math.max(0, cols - railCols);
  const sigRows = Math.max(0, rows - railRows);

  return { cols: sigCols, rows: sigRows, total: sigCols * sigRows };
}

// ─── Gerber file generators ───────────────────────────────────────────

export function generateEdgeCuts(config) {
  const { width, height } = config;
  let gerber = GERBER_HEADER('Edge.Cuts');

  gerber += `%ADD10C,0.100000*%\n`;
  gerber += `D10*\n`;

  gerber += `X${fmtCoord(0)}Y${fmtCoord(0)}D02*\n`;
  gerber += `X${fmtCoord(width)}Y${fmtCoord(0)}D01*\n`;
  gerber += `X${fmtCoord(width)}Y${fmtCoord(height)}D01*\n`;
  gerber += `X${fmtCoord(0)}Y${fmtCoord(height)}D01*\n`;
  gerber += `X${fmtCoord(0)}Y${fmtCoord(0)}D01*\n`;

  gerber += GERBER_FOOTER;
  return gerber;
}

export function generateCopperLayer(config, layerName = 'B.Cu') {
  const pads = generatePadPositions(config);
  const traces = generatePowerRailTraces(config);
  const { padDiameter, annularRing } = config;

  let gerber = GERBER_HEADER(layerName);

  const copperPadDia = padDiameter + annularRing * 2;
  gerber += `%ADD10C,${copperPadDia.toFixed(6)}*%\n`; // Signal pad
  gerber += `%ADD11C,${copperPadDia.toFixed(6)}*%\n`; // VCC pad
  gerber += `%ADD12C,${copperPadDia.toFixed(6)}*%\n`; // GND pad
  gerber += `%ADD20C,${GERBER_RAIL_TRACE_WIDTH.toFixed(6)}*%\n`; // Rail trace

  for (const pad of pads) {
    const aperture = pad.type === 'vcc' ? 'D11' : pad.type === 'gnd' ? 'D12' : 'D10';
    gerber += `${aperture}*\n`;
    gerber += `X${fmtCoord(pad.x)}Y${fmtCoord(pad.y)}D03*\n`;
  }

  if (traces.length > 0) {
    gerber += `D20*\n`;
    for (const t of traces) {
      gerber += `X${fmtCoord(t.x1)}Y${fmtCoord(t.y1)}D02*\n`;
      gerber += `X${fmtCoord(t.x2)}Y${fmtCoord(t.y2)}D01*\n`;
    }
  }

  gerber += GERBER_FOOTER;
  return gerber;
}

export function generateSolderMask(config, layerName = 'B.Mask') {
  const pads = generatePadPositions(config);
  const { padDiameter, annularRing, maskExpansion } = config;

  let gerber = GERBER_HEADER(layerName);

  const maskDia = padDiameter + annularRing * 2 + maskExpansion * 2;
  gerber += `%ADD10C,${maskDia.toFixed(6)}*%\n`;
  gerber += `D10*\n`;

  for (const pad of pads) {
    gerber += `X${fmtCoord(pad.x)}Y${fmtCoord(pad.y)}D03*\n`;
  }

  gerber += GERBER_FOOTER;
  return gerber;
}

export function generateSilkscreen(config) {
  let gerber = GERBER_HEADER('F.Silkscreen');
  gerber += `%ADD10C,0.150000*%\n`;
  gerber += `D10*\n`;
  gerber += GERBER_FOOTER;
  return gerber;
}

export function generateDrillFile(config) {
  const pads = generatePadPositions(config);
  const { padDiameter } = config;

  let drill = `; ProtoGrid - Parametric Prototype PCB\n`;
  drill += `; Drill file - Excellon format\n`;
  drill += `M48\n`;
  drill += `METRIC,TZ\n`;
  drill += `T1C${padDiameter.toFixed(3)}\n`;
  drill += `%\n`;
  drill += `T1\n`;

  for (const pad of pads) {
    drill += `X${pad.x.toFixed(3)}Y${pad.y.toFixed(3)}\n`;
  }

  drill += `M30\n`;
  return drill;
}

/**
 * Generate complete Gerber file set
 */
export function generateAllFiles(config) {
  const cfg = {
    maskExpansion: 0.05,
    ...config,
  };

  return {
    'ProtoGrid-Edge_Cuts.gbr': generateEdgeCuts(cfg),
    'ProtoGrid-B_Cu.gbr': generateCopperLayer(cfg, 'B.Cu'),
    'ProtoGrid-F_Cu.gbr': generateCopperLayer(cfg, 'F.Cu'),
    'ProtoGrid-B_Mask.gbr': generateSolderMask(cfg, 'B.Mask'),
    'ProtoGrid-F_Mask.gbr': generateSolderMask(cfg, 'F.Mask'),
    'ProtoGrid-F_Silkscreen.gbr': generateSilkscreen(cfg),
    'ProtoGrid.drl': generateDrillFile(cfg),
  };
}
